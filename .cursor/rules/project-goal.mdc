---
description: To understand the main project goal and the possible imagined flow that would be implemented based on the Hummingbot's official latest repo.
globs: 
alwaysApply: false
---
# Integrating a Custom **QTX** Exchange Connector into Hummingbot

## Introduction
Integrating a proprietary **QTX** exchange feed into Hummingbot’s architecture requires building a **custom CLOB connector** that consumes external data (via UDP or shared memory) and exposes it through Hummingbot’s strategy engine.  
The connector must support **low-latency market-data ingestion**—Level 1 quotes, Level 2 order-book updates, and trade ticks—while providing a clear path to **order placement, cancellation, and user-stream handling**.  
During initial rollout you can rely on Hummingbot’s built-in **paper-trading mode** for strategy testing, then enable live trading features once your infrastructure is ready.

---

## 1  Hummingbot Connector Architecture Overview

| Component | Purpose |
|-----------|---------|
| **Exchange class** | Main connector class; owns order-book tracker, (future) user-stream tracker, and order-routing helpers |
| **Order-book data source** | Retrieves snapshots & incremental updates; parses them into `OrderBookMessage`s |
| **OrderBookTracker** | Consumes messages, maintains an in-memory order book |
| **User-stream data source** | Listens for private events such as balances & order updates (enable when live trading starts) |
| **Auth helper** | Signs REST/FIX calls for order placement & cancellation |

Hummingbot favours streaming data for low latency, so replacing the WebSocket layer with a local UDP/shared-memory listener aligns naturally with its design principles.

---

## 2  Designing the Custom Connector

### 2.1  Data-flow pipeline
1. **Feed listener** – open a UDP socket *or* attach to shared memory via `mmap()` inside an async task.  
2. **Parse & normalise** – translate proprietary messages into `OrderBookMessage`s and `TradeMessage`s.  
3. **Publish to tracker** – queue messages into `OrderBookTracker` so strategies receive standard events.  
4. **Latency safeguards** – enlarge socket buffers, parse efficiently (e.g., `struct.unpack`), optionally dedicate a worker thread.

### 2.2  Trading-function stubs
Implement `place_order`, `cancel_order`, and other trading APIs to **delegate to paper trading** at first (or raise a controlled “NotImplementedYet” error).  
This keeps the interface complete while you develop and test against the live feed.

### 2.3  Road map to full trading support
* **Hybrid model** – keep your proprietary feed for data; call the exchange’s REST/FIX API for orders.  
* **Full internal routing** – if your infra will also send orders, expose that interface and emit Hummingbot events (`OrderFilledEvent`, etc.).  
Design the class skeleton now so these features plug in later without rewrites.

---

## 3  Extension Points in Hummingbot
* **`OrderBookTrackerDataSource`** – create `qtx_order_book_data_source.py` implementing `listen_for_order_book_snapshots/diffs`.  
* **`UserStreamTrackerDataSource`** – add once private order events are available.  
* **Connector registration** – add your module under `hummingbot.connector.exchange.qtx`. Extend `ALL_CONNECTORS` (via small patch or runtime monkey-patch).  
* Follow the Spot v2.1 connector template so upgrades & community tooling work out-of-box.

---

## 4  Packaging & Distribution Options

| Approach | Pros | Cons | When to choose |
|----------|------|------|----------------|
| **Pip/Plugin** | Simple install (`pip install hummingbot-qtx`); no fork | Needs tiny patch to register connector | Best for public distribution |
| **Docker image** | One-command run; fully controlled env | Users rely on your image; must rebuild for each HB release | Good for non-dev users |
| **Forked repo** | Quick to code | Ongoing merge burden; fragmented versions | Acceptable for internal use |
| **Upstream PR / future plugin manager** | Maintained by core; zero install steps | Requires open-sourcing & Foundation approval | Long-term goal |

**Recommendation:** strive for **plugin + optional Docker**. Keep code outside core, publish installation docs, and automate regression tests to stay compatible with new Hummingbot releases.

---

## 5  Lessons from Community Connectors
* Many connectors (Bitstamp, Hashkey, etc.) started external and were merged upstream after following the template.  
* Maintenance-status badges show the importance of **ongoing upkeep**—invest in CI early.  
* Gateway connectors prove that **decoupled modules work**—mimic that pattern for the QTX CLOB connector.

---

## 6  Conclusion
A proprietary low-latency feed can slot neatly into Hummingbot by **re-implementing only the data-source layer** while reusing its battle-tested strategy engine and order-book tracker.  
Leverage paper trading for early validation, architect with future order routing in mind, and distribute as a plugin or Docker image for the smoothest user experience.
