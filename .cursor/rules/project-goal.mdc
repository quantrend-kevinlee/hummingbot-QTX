---
description: To understand the main project goal and the possible imagined flow that would be implemented based on the Hummingbot's official latest repo.
globs: 
alwaysApply: false
---

# Integrating a Custom Market Data Feed into Hummingbot

## Introduction
Integrating a proprietary market‑data feed into Hummingbot’s architecture requires building a **custom CLOB connector** that consumes external data (via UDP or shared memory) and feeds it into Hummingbot’s strategy engine.  
This connector will initially handle **market data only** – Level 1 quotes, Level 2 order‑book data, and trade ticks – with a clear upgrade path to **order placement** in the future.  
The challenge is to do this in a **modular, maintainable** way that minimises changes to core Hummingbot.

## 1  Hummingbot Connector Architecture Overview
Hummingbot exchange connectors follow a common interface defined by `ConnectorBase` (via `ExchangeBase` / `DerivativeBase`).  
Key CLOB pieces:

| Component | Purpose |
|-----------|---------|
| **Exchange class** | Main connector class; holds order‑book tracker & (future) user stream tracker |
| **Order‑book data source** | Retrieves snapshots & incremental updates; parses them into `OrderBookMessage`s |
| **OrderBookTracker** | Consumes messages, maintains an in‑memory order book |
| **User‑stream data source** | (Future) listens for private events such as balances & order updates |
| **Auth helper** | (Future) signs API calls for order placement |

Hummingbot favours streaming data for low latency, so replacing the WebSocket layer with a local UDP/shared‑memory listener aligns well with its design.

## 2  Designing the Custom Connector

### 2.1  Market‑data flow
1. **Feed listener** – open a UDP socket *or* attach to shared memory via `mmap()` in an async task.<br>  
2. **Parse & normalise** – translate proprietary messages into `OrderBookMessage`s and `TradeMessage`s.  
3. **Publish to tracker** – queue messages into `OrderBookTracker` so any strategy sees standard events.  
4. **Latency safeguards** – enlarge socket buffers, parse efficiently (e.g., `struct.unpack`), optionally dedicate a worker thread.

### 2.2  Stubbed trading functions
Until order routing is added, implement `place_order` / `cancel_order` as no‑ops that raise a controlled exception or return a dummy result.  
This lets read‑only strategies (e.g. data‑logging or reference‑price arbitrage) run without modification.

### 2.3  Road map to order placement
* **Hybrid model** – keep your proprietary feed for data; call the exchange’s REST/FIX API for orders.  
* **Or full internal routing** – if your infra will also send orders, expose that interface in the connector and emit Hummingbot standard events (`OrderFilledEvent`, etc.).  
Design the class skeleton now so these features plug in later without rewrites.

## 3  Extension Points in Hummingbot
* **`OrderBookTrackerDataSource`** – create `custom_feed_order_book_data_source.py` implementing `listen_for_order_book_snapshots/diffs`.  
* **`UserStreamTrackerDataSource`** – add when private order events are available.  
* **Connector registration** – add your module under `hummingbot.connector.exchange.myfeed`. Extend the `ALL_CONNECTORS` mapping (via small patch or monkey‑patch at runtime).  
* **Follow connector template** – use the Spot v2.1 guidelines so upgrades & community tooling work out‑of‑box.

## 4  Packaging & Distribution Options

| Approach | Pros | Cons | When to choose |
|----------|------|------|----------------|
| **Pip/Plugin** | Simple install (`pip install hummingbot-myfeed`); no fork | Needs tiny patch to register connector | Best for public distribution |
| **Docker image** | One‑command run; fully controlled env | Users rely on your image; must rebuild for each HB release | Good for non‑dev users |
| **Forked repo** | Quick to code | Ongoing merge burden; fragmented versions | Acceptable for internal use |
| **Upstream PR / future plugin manager** | Maintained by core; zero install steps | Requires open‑sourcing & Foundation approval | Long‑term goal |

**Recommendation:** strive for **plugin + optional Docker**. Keep code outside core, publish installation docs, and automate regression tests to stay compatible with new Hummingbot releases.

## 5  Lessons from Community Connectors
* Many connectors (Bitstamp, Hashkey, etc.) started as external contributions and were merged once they followed the template.  
* Community maintenance status badges highlight the need for **ongoing upkeep**. Invest in tests and CI early.  
* Gateway connectors prove that **decoupled modules work** – mimic that pattern for a CLOB connector.

## 6  Checklist for First Release
- [ ] Connector skeleton inheriting from `ExchangeBase`  
- [ ] `CustomFeedOrderBookDataSource` with UDP/SHM listener  
- [ ] Transformation to `OrderBookMessage` / `TradeMessage`  
- [ ] Unit tests for snapshot + diff sequencing  
- [ ] Minimal config schema (`host`, `port`, `shm_name`, etc.)  
- [ ] PyPI package & installation guide  
- [ ] (Optional) Dockerfile extending official hummingbot image  

## 7  Conclusion
A proprietary low‑latency feed can slot neatly into Hummingbot by **re‑implementing only the data‑source layer** while reusing its battle‑tested strategy engine and order‑book tracker.  
Plan future trading features now, follow the connector standard, and distribute as a plugin or Docker image for the smoothest user experience.
