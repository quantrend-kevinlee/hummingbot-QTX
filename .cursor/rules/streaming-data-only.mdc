---
description: To understand the main imagined flow of the streaming-majored approach through our UDP/shared memory source
globs: 
alwaysApply: false
---

# Integrating a **Stream‑Only** Market‑Data Feed into Hummingbot  
*(UDP / Shared‑Memory → Order‑Book & Trade Events)*

## 1 Why “stream‑only”?

Many exchanges expose REST endpoints for snapshots, balances, etc.  
Your proprietary feed **already delivers snapshots, diffs, and trades via UDP or shared memory**, with lower latency than HTTP.  
Therefore the connector can **skip REST completely** and rely 100 % on streaming messages – just like a WebSocket‑only exchange.

---

## 2 Minimal Pieces You Still Need

| Piece | Purpose | Implementation in a stream‑only world |
|-------|---------|---------------------------------------|
| **`OrderBookTrackerDataSource`** | Emits snapshots, diffs, and trades | Reads UDP packets or polls shared memory, converts to `OrderBookMessage` / `TradeMessage` |
| **`OrderBookTracker`** | Maintains the in‑memory order book | Unchanged – consumes the messages you emit |
| **`ExchangeBase` subclass** | Glue between tracker and Hummingbot strategies | Overrides any REST‑related coroutines as *no‑ops* |
| **(Future) UserStreamTrackerDataSource** | Ack / fill / balance events if you add trading | Same pattern – read from feed, no REST backup |

No throttler, no HTTP client, no polling tasks required.

---

## 3 Eliminating REST Touch‑points

| Standard coroutine | Why it exists | Stream‑only action |
|--------------------|---------------|--------------------|
| `_async_update_trading_rules()` | Polls min/step sizes | Hard‑code rules or load once from a local file, then `return` |
| `listen_for_order_book_snapshots()` default impl | Fetches snapshot via REST | Replace with *stream‑built* snapshots (see §4) |
| `_update_balances()` / `_update_tracked_orders()` | REST backup for user data | Stub until you add a private feed |
| `APIThrottler` / `WebAssistant` | Rate‑limit & wrap HTTP | Delete; set `self._throttler = None` |

---

## 4 Skeleton Code

### 4.1  Data Source
```python
class CustomFeedOrderBookDataSource(OrderBookTrackerDataSource):
    SNAPSHOT_INTERVAL = 60  # seconds; tune as needed

    def __init__(self, udp_host: str, udp_port: int, shm_name: str | None):
        super().__init__()
        self._udp_host, self._udp_port = udp_host, udp_port
        self._shm_name = shm_name
        self._snapshots: dict[str, OrderBookMessage] = {}

    # ---- mandatory helper ----
    @classmethod
    async def get_exchange_trading_pairs(cls):
        return ["BTC-USDT", "ETH-USDT"]

    # ---- stream loops ----
    async def listen_for_order_book_diffs(self, ev_loop, output):
        async for raw in self._raw_packets(kind="diff"):
            await output.put(self._parse_diff(raw))

    async def listen_for_trades(self, ev_loop, output):
        async for raw in self._raw_packets(kind="trade"):
            await output.put(self._parse_trade(raw))

    async def listen_for_order_book_snapshots(self, ev_loop, output):
        while True:
            for pair in await self.get_exchange_trading_pairs():
                snap = await self._build_snapshot_from_feed(pair)
                self._snapshots[pair] = snap
                await output.put(snap)
            await asyncio.sleep(self.SNAPSHOT_INTERVAL)

    # ---- internal helpers (UDP / SHM) ----
    async def _raw_packets(self, kind=None):
        # asyncio Datagram or shared‑memory polling…
        ...
```

### 4.2  Connector Class
```python
class CustomFeedExchange(ExchangeBase):
    def __init__(self, *, udp_host: str, udp_port: int, shm_name: str | None):
        super().__init__()
        self._order_book_tracker = OrderBookTracker(
            data_source=CustomFeedOrderBookDataSource(
                udp_host=udp_host, udp_port=udp_port, shm_name=shm_name
            )
        )

    # ---------- REST stubs ----------
    async def _async_update_trading_rules(self):
        return

    async def _update_balances(self):
        pass

    async def _update_tracked_orders(self):
        pass

    # ---------- flag so strategies know REST is off ----------
    @property
    def rest_backup_enabled(self) -> bool:
        return False
```

---

## 5 Distribution Strategy Remains the Same

* **Plugin / PyPI package** – ship `hummingbot_connector_myfeed`, users `pip install` and add `"myfeed"` in config.  
* **Docker image** – base on official image, copy your module, patch `ALL_CONNECTORS`.  

No REST libs = fewer dependencies, smaller footprint.

---

## 6 Testing Matrix

1. **Unit tests** – feed mock frames into parsers, assert correct messages.  
2. **Integration** – run Hummingbot in paper mode; verify depth updates; confirm **no HTTP** traffic.  
3. **Throughput soak** – replay 1 M packets @ 10 kpps; track dropped frames & latency.  
4. **Failure modes** – kill feed; connector sets `NetworkStatus.NOT_CONNECTED`; strategies pause gracefully.

---

## 7 Road‑map to Trading Support

* Add `UserStreamTrackerDataSource` that listens to proprietary ACK/fill channel.  
* Implement `place_order()` via exchange REST **or** internal engine.  
* Emit events (`OrderCreated`/`OrderFilled`/`OrderCancelled`) so strategies work unchanged.

---

## 8 Key Take‑aways

* **Hummingbot does not require REST.**  
* Implement three streaming coroutines; stub everything else.  
* You get lowest latency while retaining full strategy compatibility.
